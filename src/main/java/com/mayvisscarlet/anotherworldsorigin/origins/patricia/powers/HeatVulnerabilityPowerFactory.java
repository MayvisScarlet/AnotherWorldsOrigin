package com.mayvisscarlet.anotherworldsorigin.origins.patricia.powers;

import com.mayvisscarlet.anotherworldsorigin.AnotherWorldsOrigin;
import com.mayvisscarlet.anotherworldsorigin.capability.AffinityCapability;
import com.mayvisscarlet.anotherworldsorigin.config.ConfigManager;
import com.mayvisscarlet.anotherworldsorigin.util.DebugDisplay;
import com.mayvisscarlet.anotherworldsorigin.util.OriginHelper;
import com.mojang.serialization.Codec;
import com.mojang.serialization.codecs.RecordCodecBuilder;
import io.github.edwinmindcraft.apoli.api.IDynamicFeatureConfiguration;
import io.github.edwinmindcraft.apoli.api.power.factory.PowerFactory;
import net.minecraft.world.entity.player.Player;
import net.minecraftforge.event.entity.living.LivingHurtEvent;
import net.minecraftforge.event.entity.player.PlayerEvent;
import net.minecraftforge.eventbus.api.EventPriority;
import net.minecraftforge.eventbus.api.SubscribeEvent;
import net.minecraftforge.fml.common.Mod;

import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

/**
 * パトリシアの「溶けた氷が固まるまで」PowerFactory
 * 熱系ダメージ脆弱性、Hot系バイオームペナルティ、回復ボーナスシステムを管理
 */
public class HeatVulnerabilityPowerFactory extends PowerFactory<HeatVulnerabilityPowerFactory.Configuration> {

    private static final UUID HEALING_RECEIVED_MODIFIER_UUID = UUID.fromString("abcdef12-3456-7890-abcd-ef1234567890");

    /**
     * Configuration用のCodec定義
     */
    public static final Codec<Configuration> CODEC = RecordCodecBuilder.create(instance -> instance.group(
            Codec.BOOL.optionalFieldOf("fire_vulnerability", true).forGetter(Configuration::fireVulnerability),
            Codec.BOOL.optionalFieldOf("hot_biome_penalties", true).forGetter(Configuration::hotBiomePenalties),
            Codec.BOOL.optionalFieldOf("recovery_bonus_system", true).forGetter(Configuration::recoveryBonusSystem),
            Codec.BOOL.optionalFieldOf("high_affinity_benefits", true).forGetter(Configuration::highAffinityBenefits))
            .apply(instance, Configuration::new));

    public HeatVulnerabilityPowerFactory() {
        super(CODEC);
    }

    /**
     * Power設定データクラス
     */
    public static record Configuration(
            boolean fireVulnerability,
            boolean hotBiomePenalties,
            boolean recoveryBonusSystem,
            boolean highAffinityBenefits) implements IDynamicFeatureConfiguration {
    }

    // ========================================
    // プレイヤー状態管理システム
    // ========================================

    /**
     * プレイヤー状態管理の静的内部クラス
     */
    public static class PlayerStateManager {
        // パトリシア種族チェックのキャッシュ（60秒間有効）
        private static final Map<UUID, PatriciaCache> patriciaCache = new ConcurrentHashMap<>();
        private static final long CACHE_DURATION = 60000; // 60秒
        
        /**
         * パトリシア種族判定結果のキャッシュデータ
         */
        private static class PatriciaCache {
            final boolean isPatricia;
            final long timestamp;
            
            PatriciaCache(boolean isPatricia, long timestamp) {
                this.isPatricia = isPatricia;
                this.timestamp = timestamp;
            }
        }

        // バイオーム状態キャッシュ
        private static final Map<UUID, BiomeState> biomeStateCache = new ConcurrentHashMap<>();

        // バイオーム変化検知の最適化用キャッシュ
        private static final Map<UUID, Long> lastBiomeCheckTime = new ConcurrentHashMap<>();
        private static final Map<UUID, net.minecraft.core.BlockPos> lastPlayerPosition = new ConcurrentHashMap<>();
        private static final long BIOME_CHECK_COOLDOWN = 5000; // 5秒

        // 回復ボーナス状態管理
        private static final Map<UUID, RecoveryBonusData> recoveryBonusCache = new ConcurrentHashMap<>();

        /**
         * パトリシア種族判定（キャッシュ付き・修正版）
         */
        public static boolean isPatriciaOptimized(Player player) {
            UUID playerId = player.getUUID();
            long currentTime = System.currentTimeMillis();

            // キャッシュから確認
            PatriciaCache cachedData = patriciaCache.get(playerId);
            if (cachedData != null && (currentTime - cachedData.timestamp) < CACHE_DURATION) {
                return cachedData.isPatricia; // 実際の判定結果を返す
            }

            // 実際の判定
            boolean isPatricia = OriginHelper.isPatricia(player);
            
            // パトリシア/非パトリシア両方の結果をキャッシュ
            patriciaCache.put(playerId, new PatriciaCache(isPatricia, currentTime));
            
            DebugDisplay.debug("AFFINITY_CALCULATION", "Patricia check for %s: %s (cached)", 
                player.getDisplayName().getString(), isPatricia);

            return isPatricia;
        }

        /**
         * バイオーム状態データクラス
         */
        public static class BiomeState {
            private boolean isHotBiome;
            private long lastUpdateTime;
            private boolean wasHotBiome; // 変化検知用

            public boolean isHotBiome() {
                return isHotBiome;
            }

            public void setHotBiome(boolean hotBiome) {
                this.isHotBiome = hotBiome;
            }

            public boolean wasHotBiome() {
                return wasHotBiome;
            }

            public void setWasHotBiome(boolean wasHotBiome) {
                this.wasHotBiome = wasHotBiome;
            }

            public long getLastUpdateTime() {
                return lastUpdateTime;
            }

            public void setLastUpdateTime(long time) {
                this.lastUpdateTime = time;
            }
        }

        /**
         * 回復ボーナスデータクラス
         */
        public static class RecoveryBonusData {
            private int remainingTicks;
            private double bonusMultiplier;
            private String triggerSource;

            public int getRemainingTicks() {
                return remainingTicks;
            }

            public void setRemainingTicks(int ticks) {
                this.remainingTicks = ticks;
            }

            public double getBonusMultiplier() {
                return bonusMultiplier;
            }

            public void setBonusMultiplier(double multiplier) {
                this.bonusMultiplier = multiplier;
            }

            public String getTriggerSource() {
                return triggerSource;
            }

            public void setTriggerSource(String source) {
                this.triggerSource = source;
            }
        }

        /**
         * バイオーム状態を取得
         */
        public static BiomeState getBiomeState(Player player) {
            return biomeStateCache.get(player.getUUID());
        }

        /**
         * 移動量ベースのバイオーム更新判定
         */
        public static void checkBiomeChangeIfMoved(Player player) {
            UUID playerId = player.getUUID();
            long currentTime = System.currentTimeMillis();
            Long lastCheck = lastBiomeCheckTime.get(playerId);

            // 移動量チェック（大きく移動した場合のみバイオーム確認）
            if (lastCheck == null || (currentTime - lastCheck) > BIOME_CHECK_COOLDOWN) {
                if (hasMovedSignificantly(player)) {
                    updateBiomeState(player, false);
                    lastBiomeCheckTime.put(playerId, currentTime);
                }
            }
        }

        /**
         * 大幅な移動を検知
         */
        private static boolean hasMovedSignificantly(Player player) {
            UUID playerId = player.getUUID();
            net.minecraft.core.BlockPos currentPos = player.blockPosition();
            net.minecraft.core.BlockPos lastPos = lastPlayerPosition.get(playerId);

            if (lastPos == null) {
                lastPlayerPosition.put(playerId, currentPos);
                return true; // 初回は必ずチェック
            }

            // 16ブロック以上移動または10秒経過時
            boolean movedFar = currentPos.distSqr(lastPos) >= 256; // 16^2
            boolean timeElapsed = player.tickCount % 200 == 0; // 10秒ごと

            if (movedFar || timeElapsed) {
                lastPlayerPosition.put(playerId, currentPos);
                return true;
            }

            return false;
        }

        /**
         * バイオーム状態更新処理
         */
        public static void updateBiomeState(Player player, boolean forceUpdate) {
            if (!isPatriciaOptimized(player))
                return;

            UUID playerId = player.getUUID();
            BiomeState state = biomeStateCache.computeIfAbsent(playerId, k -> new BiomeState());

            var biome = player.level().getBiome(player.blockPosition()).value();
            var config = ConfigManager.getPatriciaConfig();
            boolean isHot = config.isHotBiome(biome.getBaseTemperature());

            if (forceUpdate || state.isHotBiome() != isHot) {
                // バイオーム変化を検知
                state.setWasHotBiome(state.isHotBiome());
                state.setHotBiome(isHot);
                state.setLastUpdateTime(System.currentTimeMillis());

                // Hot系バイオーム入退場処理
                onBiomeChanged(player, state.wasHotBiome(), isHot);
            }
        }

        /**
         * バイオーム変化時の処理
         */
        private static void onBiomeChanged(Player player, boolean wasHot, boolean isHot) {
            var config = ConfigManager.getPatriciaConfig();

            if (!wasHot && isHot) {
                // Hot系バイオーム入場
                if (config.shouldShowDebugMessages()) {
                    player.displayClientMessage(
                            net.minecraft.network.chat.Component.literal("§6[溶けた氷が固まるまで] §7Hot系バイオームに入場"),
                            true);
                }
                DebugDisplay.debug(player, "BIOME_DETECTION", "Patricia %s entered hot biome",
                        player.getDisplayName().getString());

            } else if (wasHot && !isHot) {
                // Hot系バイオーム退場
                if (config.shouldShowDebugMessages()) {
                    player.displayClientMessage(
                            net.minecraft.network.chat.Component.literal("§b[溶けた氷が固まるまで] §7Hot系バイオーム退場"),
                            true);
                }
                DebugDisplay.debug(player, "BIOME_DETECTION", "Patricia %s left hot biome",
                        player.getDisplayName().getString());
            }
        }

        /**
         * 疲労値消費が発生する行動かを判定
         */
        public static boolean isExhaustionCausingAction(Player player) {
            return player.isSprinting() ||
                    player.isSwimming() ||
                    player.getDeltaMovement().lengthSqr() > 0.01 || // 移動中
                    player.swingTime > 0 || // 腕を振っている
                    player.attackAnim > 0; // 攻撃中
        }

        /**
         * 定期的なキャッシュサイズ監視
         */
        public static void monitorCacheSize() {
            if (biomeStateCache.size() > 100) { // 100プレイヤー以上でクリーンアップ
                cleanupInactiveEntries();
            }
        }

        /**
         * 非アクティブエントリのクリーンアップ
         */
        private static void cleanupInactiveEntries() {
            long currentTime = System.currentTimeMillis();
            biomeStateCache.entrySet().removeIf(entry -> (currentTime - entry.getValue().getLastUpdateTime()) > 300000); // 5分以上未更新

            // 位置キャッシュもクリーンアップ
            lastBiomeCheckTime.entrySet().removeIf(entry -> (currentTime - entry.getValue()) > 300000);

            DebugDisplay.debug("PERFORMANCE", "Cleaned up inactive biome cache entries");
        }

        /**
         * 回復ボーナス状態を取得
         */
        public static RecoveryBonusData getRecoveryBonusData(Player player) {
            return recoveryBonusCache.get(player.getUUID());
        }

        /**
         * キャッシュクリーンアップ
         */
        public static void cleanupCache() {
            long currentTime = System.currentTimeMillis();
            patriciaCache.entrySet().removeIf(entry -> (currentTime - entry.getValue().timestamp) > CACHE_DURATION);
        }

        /**
         * プレイヤーがパトリシア種族でなくなった時のクリーンアップ
         */
        public static void onPatriciaDeactivated(Player player) {
            UUID playerId = player.getUUID();

            patriciaCache.remove(playerId);
            biomeStateCache.remove(playerId);
            recoveryBonusCache.remove(playerId);

            DebugDisplay.info(player, "HEAT_DAMAGE", "Patricia %s Heat Vulnerability passive deactivated",
                    player.getDisplayName().getString());
        }
    }

    // ========================================
    // 熱ダメージ計算システム
    // ========================================

    /**
     * 熱ダメージ計算の静的内部クラス
     */
    public static class HeatDamageCalculator {

        /**
         * 熱系ダメージソースの包括的判定
         */
        public static boolean isHeatDamage(net.minecraft.world.damagesource.DamageSource damageSource) {
            try {
                // 直接的な熱ダメージタイプ
                if (damageSource.is(net.minecraft.world.damagesource.DamageTypes.ON_FIRE) ||
                        damageSource.is(net.minecraft.world.damagesource.DamageTypes.IN_FIRE) ||
                        damageSource.is(net.minecraft.world.damagesource.DamageTypes.LAVA) ||
                        damageSource.is(net.minecraft.world.damagesource.DamageTypes.HOT_FLOOR)) {
                    return true;
                }

                // エンティティベースの熱ダメージ
                net.minecraft.world.entity.Entity directEntity = damageSource.getDirectEntity();
                if (directEntity != null) {
                    return isHeatEntity(directEntity);
                }

                // その他のカスタム熱系判定
                return isCustomHeatDamage(damageSource);

            } catch (Exception e) {
                DebugDisplay.error("HEAT_DAMAGE", "Error checking heat damage: %s", e.getMessage());
                return false;
            }
        }

        /**
         * 熱系エンティティの判定
         */
        private static boolean isHeatEntity(net.minecraft.world.entity.Entity entity) {
            // ブレイズ
            if (entity instanceof net.minecraft.world.entity.monster.Blaze) {
                return true;
            }

            // マグマキューブ
            if (entity instanceof net.minecraft.world.entity.monster.MagmaCube) {
                return true;
            }

            // 火の玉系
            if (entity instanceof net.minecraft.world.entity.projectile.LargeFireball ||
                    entity instanceof net.minecraft.world.entity.projectile.SmallFireball) {
                return true;
            }

            // ファイアチャージ
            if (entity.getType().toString().toLowerCase().contains("fire")) {
                return true;
            }

            // 燃えているエンティティからの攻撃
            if (entity.isOnFire()) {
                return true;
            }

            return false;
        }

        /**
         * カスタム熱系ダメージの判定（他MOD対応）
         */
        private static boolean isCustomHeatDamage(net.minecraft.world.damagesource.DamageSource damageSource) {
            String damageTypeName = damageSource.getMsgId().toLowerCase();

            // 一般的な熱系ダメージ名
            return damageTypeName.contains("fire") ||
                    damageTypeName.contains("burn") ||
                    damageTypeName.contains("lava") ||
                    damageTypeName.contains("magma") ||
                    damageTypeName.contains("heat") ||
                    damageTypeName.contains("flame") ||
                    damageTypeName.contains("scorch");
        }

        /**
         * 火炎ダメージ倍率計算
         */
        public static float calculateFireDamageMultiplier(Player player) {
            return AffinityCapability.getAffinityData(player)
                    .map(affinityData -> {
                        var config = ConfigManager.getPatriciaConfig();
                        int affinityLevel = affinityData.getAffinityData().getAffinityLevel();
                        return (float) config.calculateFireDamageMultiplier(affinityLevel);
                    })
                    .orElse(2.0f); // デフォルト200%
        }
    }

    // ========================================
    // 回復ボーナス管理システム（Phase 3で実装予定）
    // ========================================

    /**
     * 回復ボーナス管理の静的内部クラス
     */
    public static class RecoveryBonusManager {

        /**
         * 回復ボーナス発動
         */
        public static void triggerRecoveryBonus(Player player, String source) {
            if (!PlayerStateManager.isPatriciaOptimized(player)) return;
            
            var config = ConfigManager.getPatriciaConfig();
            
            AffinityCapability.getAffinityData(player).ifPresent(affinityData -> {
                int affinityLevel = affinityData.getAffinityData().getAffinityLevel();
                
                // 回復ボーナス計算
                int baseDuration = config.calculateRecoveryDuration(affinityLevel);
                
                // 効果時間: バイオーム滞在効果のみ10倍、熱ダメージは通常時間
                int duration;
                if (source.equals("hot_biome_endurance") || source.equals("high_affinity_cold")) {
                    duration = baseDuration * 10; // バイオーム効果のみ10倍
                } else {
                    duration = baseDuration; // 熱ダメージ等は通常時間
                }
                
                double increase = config.calculateRecoveryIncrease(affinityLevel);
                
                // 既存のボーナスを除去
                removeHealingBonus(player);
                
                // 新しいボーナスを適用
                applyHealingBonus(player, increase, duration);
                
                // プレイヤーデータに記録
                PlayerStateManager.RecoveryBonusData bonusData = new PlayerStateManager.RecoveryBonusData();
                bonusData.setRemainingTicks(duration);
                bonusData.setBonusMultiplier(1.0 + increase);
                bonusData.setTriggerSource(source);
                
                PlayerStateManager.recoveryBonusCache.put(player.getUUID(), bonusData);
                
                // プレイヤーに通知（修正: 正確な値表示）
                DebugDisplay.info(player, "RECOVERY_BONUS", "§a[回復ボーナス] §f%.0f%% 増加 (%d秒)", 
                    increase * 100, duration / 20);
                
                DebugDisplay.info(player, "RECOVERY_BONUS", "Recovery bonus triggered for %s: source=%s, increase=%.1f%%, total_multiplier=%.1fx, duration=%ds",
                    player.getDisplayName().getString(), source, increase * 100, 1.0 + increase, duration / 20);
            });
        }

        /**
         * 回復ボーナス終了処理
         */
        public static void endRecoveryBonus(Player player) {
            // AttributeModifier を除去
            removeHealingBonus(player);
            
            // キャッシュからデータを除去
            PlayerStateManager.recoveryBonusCache.remove(player.getUUID());
            
            // プレイヤーに通知
            DebugDisplay.info(player, "RECOVERY_BONUS", "§7[回復ボーナス] §f効果が終了しました");
            
            DebugDisplay.debug(player, "RECOVERY_BONUS", "Recovery bonus ended for %s",
                player.getDisplayName().getString());
        }

        /**
         * Healing Received 属性ボーナスを適用
         */
        private static void applyHealingBonus(Player player, double multiplier, int durationTicks) {
            try {
                // Apothic Attributes の Healing Received 属性を取得
                var healingAttribute = getHealingReceivedAttribute(player);
                if (healingAttribute != null) {
                    // 既存の修飾子を除去（安全性のため）
                    healingAttribute.removeModifier(HEALING_RECEIVED_MODIFIER_UUID);
                    
                    // 新しい修飾子を追加（仕様変更: 乗算効果）
                    net.minecraft.world.entity.ai.attributes.AttributeModifier modifier = 
                        new net.minecraft.world.entity.ai.attributes.AttributeModifier(
                            HEALING_RECEIVED_MODIFIER_UUID,
                            "Patricia Recovery Bonus",
                            multiplier, // MULTIPLY_TOTAL用の増加値
                            net.minecraft.world.entity.ai.attributes.AttributeModifier.Operation.MULTIPLY_TOTAL
                        );
                    
                    healingAttribute.addPermanentModifier(modifier);
                    
                    DebugDisplay.debug(player, "RECOVERY_BONUS", "Applied healing bonus to %s: %.1fx for %d ticks",
                        player.getDisplayName().getString(), multiplier, durationTicks);
                } else {
                    DebugDisplay.warn(player, "RECOVERY_BONUS", "Healing Received attribute not found for player: %s",
                        player.getDisplayName().getString());
                    // フォールバック実装を呼び出し
                    applyFallbackHealingBonus(player, multiplier, durationTicks);
                }
            } catch (Exception e) {
                DebugDisplay.error(player, "RECOVERY_BONUS", "Failed to apply healing bonus to %s: %s",
                    player.getDisplayName().getString(), e.getMessage());
            }
        }

        /**
         * Healing Received 属性ボーナスを除去
         */
        private static void removeHealingBonus(Player player) {
            try {
                var healingAttribute = getHealingReceivedAttribute(player);
                if (healingAttribute != null) {
                    healingAttribute.removeModifier(HEALING_RECEIVED_MODIFIER_UUID);
                    DebugDisplay.debug(player, "RECOVERY_BONUS", "Removed healing bonus from %s",
                        player.getDisplayName().getString());
                }
            } catch (Exception e) {
                DebugDisplay.error(player, "RECOVERY_BONUS", "Failed to remove healing bonus from %s: %s",
                    player.getDisplayName().getString(), e.getMessage());
            }
        }

        /**
         * Apothic Attributes の Healing Received 属性を取得
         */
        private static net.minecraft.world.entity.ai.attributes.AttributeInstance getHealingReceivedAttribute(Player player) {
            try {
                // Apothic Attributes の Healing Received 属性を正しく取得
                Class<?> alObjectsClass = Class.forName("dev.shadowsoffire.attributeslib.api.ALObjects");
                Class<?> attributesClass = Class.forName("dev.shadowsoffire.attributeslib.api.ALObjects$Attributes");
                
                // HEALING_RECEIVED フィールドを取得（RegistryObjectとして）
                java.lang.reflect.Field healingReceivedField = attributesClass.getField("HEALING_RECEIVED");
                Object healingReceivedRegistry = healingReceivedField.get(null);
                
                // RegistryObject から実際の Attribute を取得
                if (healingReceivedRegistry instanceof net.minecraftforge.registries.RegistryObject) {
                    net.minecraftforge.registries.RegistryObject<?> registryObject = 
                        (net.minecraftforge.registries.RegistryObject<?>) healingReceivedRegistry;
                    
                    Object attributeObj = registryObject.get();
                    if (attributeObj instanceof net.minecraft.world.entity.ai.attributes.Attribute) {
                        net.minecraft.world.entity.ai.attributes.Attribute healingReceivedAttr = 
                            (net.minecraft.world.entity.ai.attributes.Attribute) attributeObj;
                        
                        return player.getAttribute(healingReceivedAttr);
                    } else {
                        DebugDisplay.warn("RECOVERY_BONUS", "HEALING_RECEIVED registry object does not contain an Attribute: %s", 
                            attributeObj != null ? attributeObj.getClass().getName() : "null");
                        return null;
                    }
                } else {
                    DebugDisplay.warn("RECOVERY_BONUS", "HEALING_RECEIVED field is not a RegistryObject: %s", 
                        healingReceivedRegistry != null ? healingReceivedRegistry.getClass().getName() : "null");
                    return null;
                }
            } catch (Exception e) {
                DebugDisplay.warn("RECOVERY_BONUS", "Apothic Attributes not available or incompatible: %s", e.getMessage());
                DebugDisplay.debug("RECOVERY_BONUS", "Full exception: %s", e.toString());
                return null; // Apothic Attributes 未導入時
            }
        }

        /**
         * 高親和度特典チェック（外部API用）
         */
        public static void checkHighAffinityBonus(Player player) {
            if (!PlayerStateManager.isPatriciaOptimized(player)) return;
            
            var config = ConfigManager.getPatriciaConfig();
            
            AffinityCapability.getAffinityData(player).ifPresent(affinityData -> {
                int affinityLevel = affinityData.getAffinityData().getAffinityLevel();
                
                // 高親和度到達時のCold系バイオーム特典
                if (config.isHighAffinityActive(affinityLevel)) {
                    var biome = player.level().getBiome(player.blockPosition()).value();
                    boolean isCold = config.isColdBiome(biome.getBaseTemperature());
                    
                    if (isCold) {
                        // Cold系バイオームでの回復ボーナス発動（外部からの直接呼び出し）
                        triggerRecoveryBonus(player, "high_affinity_cold_manual");
                        
                        if (config.shouldShowDebugMessages()) {
                            DebugDisplay.info(player, "RECOVERY_BONUS", "§b[高親和度特典] §fCold系バイオームで回復ボーナス発動");
                        }
                    }
                }
            });
        }
        
        /**
         * Apothic Attributes 連携のフォールバック実装
         * （Apothic Attributes が利用できない場合の代替実装）
         */
        private static void applyFallbackHealingBonus(Player player, double multiplier, int durationTicks) {
            // Apothic Attributes が利用できない場合、カスタム実装で回復効果を提供
            DebugDisplay.info(player, "RECOVERY_BONUS", "§a[回復ボーナス] §f%.0f%% 増加予定 (%d秒) §7※Apothic Attributes未導入", 
                (multiplier - 1.0) * 100, durationTicks / 20);
            
            // TODO: カスタム回復システムの実装（将来のアップデート）
            DebugDisplay.info(player, "RECOVERY_BONUS", "Recovery bonus would be applied: %.1fx for %d ticks (fallback mode)",
                multiplier, durationTicks);
        }
    }

    // ========================================
    // 公開API
    // ========================================

    /**
     * プレイヤーがパトリシア種族になった時の初期化
     */
    public static void onPatriciaActivated(Player player) {
        if (!PlayerStateManager.isPatriciaOptimized(player)) {
            DebugDisplay.warn(player, "HEAT_DAMAGE", 
                    "Attempted to activate Patricia heat vulnerability for non-Patricia player: %s",
                    player.getDisplayName().getString());
            return;
        }

        DebugDisplay.info(player, "HEAT_DAMAGE", "Patricia %s Heat Vulnerability passive activated",
                player.getDisplayName().getString());

        // プレイヤーに通知
        player.sendSystemMessage(
                net.minecraft.network.chat.Component.literal("§c[Patricia] §f溶けた氷が固まるまでが発動しました"));

        // 現在の火炎ダメージ倍率を表示
        AffinityCapability.getAffinityData(player).ifPresent(affinityData -> {
            int level = affinityData.getAffinityData().getAffinityLevel();
            double multiplier = ConfigManager.getPatriciaConfig().calculateFireDamageMultiplier(level);
            player.sendSystemMessage(
                    net.minecraft.network.chat.Component.literal(
                            String.format("§c[熱ダメージ倍率] §c%.0f%% §7(親和度Lv.%d)", multiplier * 100, level)));
        });
    }

    /**
     * 親和度レベルアップ時の特別処理
     */
    public static void onAffinityLevelUp(Player player, int newLevel, int oldLevel) {
        if (!PlayerStateManager.isPatriciaOptimized(player)) {
            return;
        }

        var patriciaConfig = ConfigManager.getPatriciaConfig();

        // 熱ダメージ軽減の改善を表示
        double oldMultiplier = patriciaConfig.calculateFireDamageMultiplier(oldLevel);
        double newMultiplier = patriciaConfig.calculateFireDamageMultiplier(newLevel);
        double improvement = oldMultiplier - newMultiplier;

        if (improvement > 0.01) { // 有意な改善がある場合
            player.sendSystemMessage(
                    net.minecraft.network.chat.Component.literal(
                            String.format("§c[熱耐性向上] §7火炎ダメージ: %.0f%% → %.0f%% (§a-%.1f%%§7)",
                                    oldMultiplier * 100, newMultiplier * 100, improvement * 100)));
        }

        // 高親和度特典達成時の特別メッセージ
        if (newLevel == patriciaConfig.getHighAffinityThreshold()) {
            player.sendSystemMessage(
                    net.minecraft.network.chat.Component.literal(
                            "§l§c[Patricia] §r§f高親和度到達！熱への耐性が大幅に向上した"));
        }

        DebugDisplay.info(player, "HEAT_DAMAGE", "Patricia %s heat vulnerability level up: %d -> %d (multiplier: %.1fx -> %.1fx)",
                player.getDisplayName().getString(), oldLevel, newLevel, oldMultiplier, newMultiplier);
    }

    // ========================================
    // イベントハンドラー
    // ========================================

    /**
     * 熱脆弱性イベントハンドラーの静的内部クラス
     */
    @Mod.EventBusSubscriber(modid = AnotherWorldsOrigin.MODID)
    public static class EventHandler {

        // デフォルト設定（パトリシア種族用）
        private static final Configuration DEFAULT_CONFIG = new Configuration(true, true, true, true);

        /**
         * 熱ダメージ脆弱性の処理
         */
        @SubscribeEvent(priority = EventPriority.HIGH)
        public static void onHeatDamage(LivingHurtEvent event) {
            if (!(event.getEntity() instanceof Player player)) {
                return;
            }

            if (!PlayerStateManager.isPatriciaOptimized(player)) {
                return;
            }

            net.minecraft.world.damagesource.DamageSource damageSource = event.getSource();

            if (HeatDamageCalculator.isHeatDamage(damageSource)) {
                float multiplier = HeatDamageCalculator.calculateFireDamageMultiplier(player);
                float originalDamage = event.getAmount();
                float newDamage = originalDamage * multiplier;

                event.setAmount(newDamage);

                // ログ出力
                DebugDisplay.info(player, "HEAT_DAMAGE", "Patricia %s heat damage vulnerability: %.2f -> %.2f (%.2fx)",
                        player.getDisplayName().getString(),
                        originalDamage,
                        newDamage,
                        multiplier);

                // デバッグ通知
                if (ConfigManager.getPatriciaConfig().shouldShowDebugMessages()) {
                    player.displayClientMessage(
                            net.minecraft.network.chat.Component.literal(String.format(
                                    "§c[熱ダメージ] §7%.1f → %.1f (%.0f%%)",
                                    originalDamage, newDamage, multiplier * 100)),
                            true);
                }

                // プレイヤーに分かりやすいフィードバック
                if (multiplier > 1.5f) { // 150%以上の場合のみ表示
                    player.displayClientMessage(
                            net.minecraft.network.chat.Component.literal(
                                    String.format("§c[溶けた氷が固まるまで] §7熱によるダメージ増加: +%.0f%%",
                                            (multiplier - 1.0f) * 100)),
                            true);
                }

                // 回復ボーナス発動トリガー（火炎・Hot系効果後）
                if (multiplier > 1.0f) { // 実際に脆弱性が適用された場合のみ
                    RecoveryBonusManager.triggerRecoveryBonus(player, "heat_damage");
                }
            }
        }

        // === EventHandler クラス内に追加するメソッド群 ===

        /**
         * Hot系バイオームでのダメージ増加
         */
        @SubscribeEvent(priority = EventPriority.LOW) // 火炎脆弱性の後に処理
        public static void onHotBiomeDamageIncrease(LivingHurtEvent event) {
            if (!(event.getEntity() instanceof Player player))
                return;
            if (!PlayerStateManager.isPatriciaOptimized(player))
                return;

            PlayerStateManager.BiomeState biomeState = PlayerStateManager.getBiomeState(player);
            if (biomeState != null && biomeState.isHotBiome()) {
                var config = ConfigManager.getPatriciaConfig();

                AffinityCapability.getAffinityData(player).ifPresent(affinityData -> {
                    int affinityLevel = affinityData.getAffinityData().getAffinityLevel();
                    double increase = config.calculateHotDamageIncrease(affinityLevel);

                    if (increase > 0) {
                        float originalDamage = event.getAmount();
                        float newDamage = originalDamage * (1.0f + (float) increase);
                        event.setAmount(newDamage);

                        // ログ出力
                        DebugDisplay.info(player, "BIOME_DETECTION", "Patricia %s hot biome damage increase: %.2f -> %.2f (+%.1f%%)",
                                player.getDisplayName().getString(),
                                originalDamage,
                                newDamage,
                                increase * 100);

                        // デバッグ通知
                        if (config.shouldShowDebugMessages()) {
                            player.displayClientMessage(
                                    net.minecraft.network.chat.Component.literal(String.format(
                                            "§6[Hot系] §7ダメージ増加: %.1f → %.1f (+%.1f%%)",
                                            originalDamage, newDamage, increase * 100)),
                                    true);
                        }
                        
                        // Hot系効果後の回復ボーナス発動（即座発動）
                        if (increase > 0) {
                            RecoveryBonusManager.triggerRecoveryBonus(player, "hot_biome_damage");
                            
                            if (config.shouldShowDebugMessages()) {
                                DebugDisplay.info(player, "RECOVERY_BONUS", "§6[熱耐性向上] §fHot系ダメージ後の回復ボーナス発動");
                            }
                        }
                    }
                });
            }
        }

        /**
         * Hot系バイオームでの満腹度処理（軽量版）
         */
        private static void handleHotBiomeExhaustion(Player player) {
            PlayerStateManager.BiomeState biomeState = PlayerStateManager.getBiomeState(player);
            if (biomeState == null || !biomeState.isHotBiome())
                return;

            // 行動中のみ追加疲労を適用
            if (PlayerStateManager.isExhaustionCausingAction(player)) {
                player.getFoodData().addExhaustion(0.1f); // 小刻みに追加で2倍効果

                var config = ConfigManager.getPatriciaConfig();
                if (config.shouldShowDebugMessages() && player.tickCount % 400 == 0) { // 20秒に1回
                    player.displayClientMessage(
                            net.minecraft.network.chat.Component.literal("§6[Hot系] §7満腹度消費増加中"),
                            true);
                }
            }
        }

        /**
         * ディメンション移動時の強制バイオーム更新
         */
        @SubscribeEvent
        public static void onPlayerChangedDimension(PlayerEvent.PlayerChangedDimensionEvent event) {
            Player player = event.getEntity();
            if (PlayerStateManager.isPatriciaOptimized(player)) {
                PlayerStateManager.updateBiomeState(player, true); // 強制更新
                DebugDisplay.debug(player, "BIOME_DETECTION", "Patricia %s biome state updated after dimension change",
                        player.getDisplayName().getString());
            }
        }

        /**
         * リスポーン時の強制バイオーム更新
         */
        @SubscribeEvent
        public static void onPlayerRespawn(PlayerEvent.PlayerRespawnEvent event) {
            Player player = event.getEntity();
            if (PlayerStateManager.isPatriciaOptimized(player)) {
                PlayerStateManager.updateBiomeState(player, true); // 強制更新
                DebugDisplay.debug(player, "BIOME_DETECTION", "Patricia %s biome state updated after respawn",
                        player.getDisplayName().getString());
            }
        }

        /**
         * プレイヤーログイン時の初期化
         */
        @SubscribeEvent
        public static void onPlayerLoggedIn(PlayerEvent.PlayerLoggedInEvent event) {
            Player player = event.getEntity();

            if (PlayerStateManager.isPatriciaOptimized(player)) {
                DebugDisplay.info(player, "HEAT_DAMAGE", "Patricia %s heat vulnerability initialized on login",
                        player.getDisplayName().getString());
            }
        }

        /**
         * 軽量化されたティック処理（処理分散版）
         */
        @SubscribeEvent
        public static void onPlayerTick(net.minecraftforge.event.entity.living.LivingEvent.LivingTickEvent event) {
            if (!(event.getEntity() instanceof Player player))
                return;

            // 早期リターンでパトリシア以外を即座に除外
            if (!PlayerStateManager.isPatriciaOptimized(player))
                return;

            // 処理を分散（各ティックで1つの処理のみ実行）
            int tickMod = player.tickCount % 100;

            if (tickMod == 0) {
                // バイオーム変化確認（5秒ごと）
                PlayerStateManager.checkBiomeChangeIfMoved(player);

            } else if (tickMod == 25) {
                // 満腹度処理（5秒ごと、バイオーム確認と分散）
                handleHotBiomeExhaustion(player);

            } else if (tickMod == 50) {
                // キャッシュクリーンアップ（5秒ごと、他と分散）
                if (player.tickCount % 6000 == 50) { // 5分ごと
                    PlayerStateManager.cleanupCache();
                    PlayerStateManager.monitorCacheSize();
                }
            } else if (tickMod == 75) {
                // 回復ボーナス管理（5秒ごと、他と分散）
                updateRecoveryBonus(player);
                
                // 回復ボーナス発動条件チェック（毎回 - 常に発動のため）
                checkAllRecoveryBonusConditions(player);
            }
        }

        /**
         * 回復ボーナスの持続時間管理
         */
        private static void updateRecoveryBonus(Player player) {
            PlayerStateManager.RecoveryBonusData bonusData = PlayerStateManager.getRecoveryBonusData(player);
            if (bonusData != null) {
                bonusData.setRemainingTicks(bonusData.getRemainingTicks() - 100); // 5秒分
                
                if (bonusData.getRemainingTicks() <= 0) {
                    DebugDisplay.debug(player, "RECOVERY_BONUS", "Recovery bonus expired for %s: source was %s", 
                        player.getDisplayName().getString(), bonusData.getTriggerSource());
                    RecoveryBonusManager.endRecoveryBonus(player);
                } else {
                    // 残り時間をデバッグ表示
                    if (bonusData.getRemainingTicks() % 1000 == 0) { // 50秒ごと
                        DebugDisplay.debug(player, "RECOVERY_BONUS", "Recovery bonus remaining for %s: %ds (source: %s)", 
                            player.getDisplayName().getString(), 
                            bonusData.getRemainingTicks() / 20,
                            bonusData.getTriggerSource());
                    }
                }
            }
        }

        /**
         * 全ての回復ボーナス発動条件をチェック（正しい仕様版）
         */
        private static void checkAllRecoveryBonusConditions(Player player) {
            var config = ConfigManager.getPatriciaConfig();
            var existingBonus = PlayerStateManager.getRecoveryBonusData(player);
            
            AffinityCapability.getAffinityData(player).ifPresent(affinityData -> {
                int affinityLevel = affinityData.getAffinityData().getAffinityLevel();
                var biome = player.level().getBiome(player.blockPosition()).value();
                float temperature = biome.getBaseTemperature();
                
                boolean isCold = config.isColdBiome(temperature);
                boolean isHot = config.isHotBiome(temperature);
                boolean isHighAffinity = config.isHighAffinityActive(affinityLevel);
                
                // 仕様: 該当バイオーム滞在中、回復ボーナスがない時のみ付与
                String expectedSource = null;
                String bonusMessage = null;
                
                // 条件判定（優先度順）
                if (isHighAffinity && isCold) {
                    // 優先度1: 高親和度 + Cold系バイオーム（常に発動）
                    expectedSource = "high_affinity_cold";
                    bonusMessage = "§b[高親和度特典] §fCold系バイオームで回復ボーナス発動";
                } else if (isHot) {
                    // 優先度2: Hot系バイオーム滞在（常に発動）
                    expectedSource = "hot_biome_endurance";
                    bonusMessage = "§6[熱耐性向上] §fHot系バイオーム滞在で回復ボーナス発動";
                }
                
                // 発動処理
                if (expectedSource != null) {
                    // 回復ボーナスがない時のみ付与
                    if (existingBonus == null) {
                        RecoveryBonusManager.triggerRecoveryBonus(player, expectedSource);
                        
                        if (config.shouldShowDebugMessages()) {
                            DebugDisplay.info(player, "RECOVERY_BONUS", bonusMessage);
                        }
                        
                        DebugDisplay.info(player, "RECOVERY_BONUS", "Biome recovery bonus triggered for %s (source: %s, Level: %d, temp: %.1f)", 
                            player.getDisplayName().getString(), expectedSource, affinityLevel, temperature);
                    } else {
                        // 滞在中は時間更新なし、既存効果をそのまま維持
                        DebugDisplay.debug(player, "RECOVERY_BONUS", "Biome recovery bonus maintained for %s (source: %s, %ds remaining)", 
                            player.getDisplayName().getString(), 
                            existingBonus.getTriggerSource(),
                            existingBonus.getRemainingTicks() / 20);
                    }
                }
                // バイオームから離れた場合は何もしない（既存効果は自然終了まで継続）
            });
        }
    }
}