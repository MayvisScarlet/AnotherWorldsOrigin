package com.mayvisscarlet.anotherworldsorigin.origins.patricia.powers;

import com.mayvisscarlet.anotherworldsorigin.AnotherWorldsOrigin;
import com.mayvisscarlet.anotherworldsorigin.capability.AffinityCapability;
import com.mayvisscarlet.anotherworldsorigin.config.ConfigManager;
import com.mayvisscarlet.anotherworldsorigin.util.OriginHelper;
import com.mojang.serialization.Codec;
import com.mojang.serialization.codecs.RecordCodecBuilder;
import io.github.edwinmindcraft.apoli.api.IDynamicFeatureConfiguration;
import io.github.edwinmindcraft.apoli.api.power.factory.PowerFactory;
import net.minecraft.world.entity.player.Player;
import net.minecraftforge.event.entity.living.LivingHurtEvent;
import net.minecraftforge.event.entity.player.PlayerEvent;
import net.minecraftforge.eventbus.api.EventPriority;
import net.minecraftforge.eventbus.api.SubscribeEvent;
import net.minecraftforge.fml.common.Mod;

import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

/**
 * パトリシアの「溶けた氷が固まるまで」PowerFactory
 * 熱系ダメージ脆弱性、Hot系バイオームペナルティ、回復ボーナスシステムを管理
 */
public class HeatVulnerabilityPowerFactory extends PowerFactory<HeatVulnerabilityPowerFactory.Configuration> {

    private static final UUID HEALING_RECEIVED_MODIFIER_UUID = UUID.fromString("abcdef12-3456-7890-abcd-ef1234567890");

    /**
     * Configuration用のCodec定義
     */
    public static final Codec<Configuration> CODEC = RecordCodecBuilder.create(instance -> instance.group(
            Codec.BOOL.optionalFieldOf("fire_vulnerability", true).forGetter(Configuration::fireVulnerability),
            Codec.BOOL.optionalFieldOf("hot_biome_penalties", true).forGetter(Configuration::hotBiomePenalties),
            Codec.BOOL.optionalFieldOf("recovery_bonus_system", true).forGetter(Configuration::recoveryBonusSystem),
            Codec.BOOL.optionalFieldOf("high_affinity_benefits", true).forGetter(Configuration::highAffinityBenefits))
            .apply(instance, Configuration::new));

    public HeatVulnerabilityPowerFactory() {
        super(CODEC);
    }

    /**
     * Power設定データクラス
     */
    public static record Configuration(
            boolean fireVulnerability,
            boolean hotBiomePenalties,
            boolean recoveryBonusSystem,
            boolean highAffinityBenefits) implements IDynamicFeatureConfiguration {
    }

    // ========================================
    // プレイヤー状態管理システム
    // ========================================

    /**
     * プレイヤー状態管理の静的内部クラス
     */
    public static class PlayerStateManager {
        // パトリシア種族チェックのキャッシュ（60秒間有効）
        private static final Map<UUID, Long> patriciaCache = new ConcurrentHashMap<>();
        private static final long CACHE_DURATION = 60000; // 60秒

        // バイオーム状態キャッシュ
        private static final Map<UUID, BiomeState> biomeStateCache = new ConcurrentHashMap<>();

        // バイオーム変化検知の最適化用キャッシュ
        private static final Map<UUID, Long> lastBiomeCheckTime = new ConcurrentHashMap<>();
        private static final Map<UUID, net.minecraft.core.BlockPos> lastPlayerPosition = new ConcurrentHashMap<>();
        private static final long BIOME_CHECK_COOLDOWN = 5000; // 5秒

        // 回復ボーナス状態管理
        private static final Map<UUID, RecoveryBonusData> recoveryBonusCache = new ConcurrentHashMap<>();

        /**
         * パトリシア種族判定（キャッシュ付き）
         */
        public static boolean isPatriciaOptimized(Player player) {
            UUID playerId = player.getUUID();
            long currentTime = System.currentTimeMillis();

            // キャッシュから確認
            Long cachedTime = patriciaCache.get(playerId);
            if (cachedTime != null && (currentTime - cachedTime) < CACHE_DURATION) {
                return true; // キャッシュヒット = パトリシア
            }

            // 実際の判定
            boolean isPatricia = OriginHelper.isPatricia(player);
            if (isPatricia) {
                patriciaCache.put(playerId, currentTime);
            } else {
                patriciaCache.remove(playerId);
            }

            return isPatricia;
        }

        /**
         * バイオーム状態データクラス
         */
        public static class BiomeState {
            private boolean isHotBiome;
            private long lastUpdateTime;
            private boolean wasHotBiome; // 変化検知用

            public boolean isHotBiome() {
                return isHotBiome;
            }

            public void setHotBiome(boolean hotBiome) {
                this.isHotBiome = hotBiome;
            }

            public boolean wasHotBiome() {
                return wasHotBiome;
            }

            public void setWasHotBiome(boolean wasHotBiome) {
                this.wasHotBiome = wasHotBiome;
            }

            public long getLastUpdateTime() {
                return lastUpdateTime;
            }

            public void setLastUpdateTime(long time) {
                this.lastUpdateTime = time;
            }
        }

        /**
         * 回復ボーナスデータクラス
         */
        public static class RecoveryBonusData {
            private int remainingTicks;
            private double bonusMultiplier;
            private String triggerSource;

            public int getRemainingTicks() {
                return remainingTicks;
            }

            public void setRemainingTicks(int ticks) {
                this.remainingTicks = ticks;
            }

            public double getBonusMultiplier() {
                return bonusMultiplier;
            }

            public void setBonusMultiplier(double multiplier) {
                this.bonusMultiplier = multiplier;
            }

            public String getTriggerSource() {
                return triggerSource;
            }

            public void setTriggerSource(String source) {
                this.triggerSource = source;
            }
        }

        /**
         * バイオーム状態を取得
         */
        public static BiomeState getBiomeState(Player player) {
            return biomeStateCache.get(player.getUUID());
        }

        /**
         * 移動量ベースのバイオーム更新判定
         */
        public static void checkBiomeChangeIfMoved(Player player) {
            UUID playerId = player.getUUID();
            long currentTime = System.currentTimeMillis();
            Long lastCheck = lastBiomeCheckTime.get(playerId);

            // 移動量チェック（大きく移動した場合のみバイオーム確認）
            if (lastCheck == null || (currentTime - lastCheck) > BIOME_CHECK_COOLDOWN) {
                if (hasMovedSignificantly(player)) {
                    updateBiomeState(player, false);
                    lastBiomeCheckTime.put(playerId, currentTime);
                }
            }
        }

        /**
         * 大幅な移動を検知
         */
        private static boolean hasMovedSignificantly(Player player) {
            UUID playerId = player.getUUID();
            net.minecraft.core.BlockPos currentPos = player.blockPosition();
            net.minecraft.core.BlockPos lastPos = lastPlayerPosition.get(playerId);

            if (lastPos == null) {
                lastPlayerPosition.put(playerId, currentPos);
                return true; // 初回は必ずチェック
            }

            // 16ブロック以上移動または10秒経過時
            boolean movedFar = currentPos.distSqr(lastPos) >= 256; // 16^2
            boolean timeElapsed = player.tickCount % 200 == 0; // 10秒ごと

            if (movedFar || timeElapsed) {
                lastPlayerPosition.put(playerId, currentPos);
                return true;
            }

            return false;
        }

        /**
         * バイオーム状態更新処理
         */
        public static void updateBiomeState(Player player, boolean forceUpdate) {
            if (!isPatriciaOptimized(player))
                return;

            UUID playerId = player.getUUID();
            BiomeState state = biomeStateCache.computeIfAbsent(playerId, k -> new BiomeState());

            var biome = player.level().getBiome(player.blockPosition()).value();
            var config = ConfigManager.getPatriciaConfig();
            boolean isHot = config.isHotBiome(biome.getBaseTemperature());

            if (forceUpdate || state.isHotBiome() != isHot) {
                // バイオーム変化を検知
                state.setWasHotBiome(state.isHotBiome());
                state.setHotBiome(isHot);
                state.setLastUpdateTime(System.currentTimeMillis());

                // Hot系バイオーム入退場処理
                onBiomeChanged(player, state.wasHotBiome(), isHot);
            }
        }

        /**
         * バイオーム変化時の処理
         */
        private static void onBiomeChanged(Player player, boolean wasHot, boolean isHot) {
            var config = ConfigManager.getPatriciaConfig();

            if (!wasHot && isHot) {
                // Hot系バイオーム入場
                if (config.shouldShowDebugMessages()) {
                    player.displayClientMessage(
                            net.minecraft.network.chat.Component.literal("§6[溶けた氷が固まるまで] §7Hot系バイオームに入場"),
                            true);
                }
                AnotherWorldsOrigin.LOGGER.debug("Patricia {} entered hot biome",
                        player.getDisplayName().getString());

            } else if (wasHot && !isHot) {
                // Hot系バイオーム退場
                if (config.shouldShowDebugMessages()) {
                    player.displayClientMessage(
                            net.minecraft.network.chat.Component.literal("§b[溶けた氷が固まるまで] §7Hot系バイオーム退場"),
                            true);
                }
                AnotherWorldsOrigin.LOGGER.debug("Patricia {} left hot biome",
                        player.getDisplayName().getString());
            }
        }

        /**
         * 疲労値消費が発生する行動かを判定
         */
        public static boolean isExhaustionCausingAction(Player player) {
            return player.isSprinting() ||
                    player.isSwimming() ||
                    player.getDeltaMovement().lengthSqr() > 0.01 || // 移動中
                    player.swingTime > 0 || // 腕を振っている
                    player.attackAnim > 0; // 攻撃中
        }

        /**
         * 定期的なキャッシュサイズ監視
         */
        public static void monitorCacheSize() {
            if (biomeStateCache.size() > 100) { // 100プレイヤー以上でクリーンアップ
                cleanupInactiveEntries();
            }
        }

        /**
         * 非アクティブエントリのクリーンアップ
         */
        private static void cleanupInactiveEntries() {
            long currentTime = System.currentTimeMillis();
            biomeStateCache.entrySet().removeIf(entry -> (currentTime - entry.getValue().getLastUpdateTime()) > 300000); // 5分以上未更新

            // 位置キャッシュもクリーンアップ
            lastBiomeCheckTime.entrySet().removeIf(entry -> (currentTime - entry.getValue()) > 300000);

            AnotherWorldsOrigin.LOGGER.debug("Cleaned up inactive biome cache entries");
        }

        /**
         * 回復ボーナス状態を取得
         */
        public static RecoveryBonusData getRecoveryBonusData(Player player) {
            return recoveryBonusCache.get(player.getUUID());
        }

        /**
         * キャッシュクリーンアップ
         */
        public static void cleanupCache() {
            long currentTime = System.currentTimeMillis();
            patriciaCache.entrySet().removeIf(entry -> (currentTime - entry.getValue()) > CACHE_DURATION);
        }

        /**
         * プレイヤーがパトリシア種族でなくなった時のクリーンアップ
         */
        public static void onPatriciaDeactivated(Player player) {
            UUID playerId = player.getUUID();

            patriciaCache.remove(playerId);
            biomeStateCache.remove(playerId);
            recoveryBonusCache.remove(playerId);

            AnotherWorldsOrigin.LOGGER.info("Patricia {} Heat Vulnerability passive deactivated",
                    player.getDisplayName().getString());
        }
    }

    // ========================================
    // 熱ダメージ計算システム
    // ========================================

    /**
     * 熱ダメージ計算の静的内部クラス
     */
    public static class HeatDamageCalculator {

        /**
         * 熱系ダメージソースの包括的判定
         */
        public static boolean isHeatDamage(net.minecraft.world.damagesource.DamageSource damageSource) {
            try {
                // 直接的な熱ダメージタイプ
                if (damageSource.is(net.minecraft.world.damagesource.DamageTypes.ON_FIRE) ||
                        damageSource.is(net.minecraft.world.damagesource.DamageTypes.IN_FIRE) ||
                        damageSource.is(net.minecraft.world.damagesource.DamageTypes.LAVA) ||
                        damageSource.is(net.minecraft.world.damagesource.DamageTypes.HOT_FLOOR)) {
                    return true;
                }

                // エンティティベースの熱ダメージ
                net.minecraft.world.entity.Entity directEntity = damageSource.getDirectEntity();
                if (directEntity != null) {
                    return isHeatEntity(directEntity);
                }

                // その他のカスタム熱系判定
                return isCustomHeatDamage(damageSource);

            } catch (Exception e) {
                AnotherWorldsOrigin.LOGGER.error("Error checking heat damage: {}", e.getMessage());
                return false;
            }
        }

        /**
         * 熱系エンティティの判定
         */
        private static boolean isHeatEntity(net.minecraft.world.entity.Entity entity) {
            // ブレイズ
            if (entity instanceof net.minecraft.world.entity.monster.Blaze) {
                return true;
            }

            // マグマキューブ
            if (entity instanceof net.minecraft.world.entity.monster.MagmaCube) {
                return true;
            }

            // 火の玉系
            if (entity instanceof net.minecraft.world.entity.projectile.LargeFireball ||
                    entity instanceof net.minecraft.world.entity.projectile.SmallFireball) {
                return true;
            }

            // ファイアチャージ
            if (entity.getType().toString().toLowerCase().contains("fire")) {
                return true;
            }

            // 燃えているエンティティからの攻撃
            if (entity.isOnFire()) {
                return true;
            }

            return false;
        }

        /**
         * カスタム熱系ダメージの判定（他MOD対応）
         */
        private static boolean isCustomHeatDamage(net.minecraft.world.damagesource.DamageSource damageSource) {
            String damageTypeName = damageSource.getMsgId().toLowerCase();

            // 一般的な熱系ダメージ名
            return damageTypeName.contains("fire") ||
                    damageTypeName.contains("burn") ||
                    damageTypeName.contains("lava") ||
                    damageTypeName.contains("magma") ||
                    damageTypeName.contains("heat") ||
                    damageTypeName.contains("flame") ||
                    damageTypeName.contains("scorch");
        }

        /**
         * 火炎ダメージ倍率計算
         */
        public static float calculateFireDamageMultiplier(Player player) {
            return AffinityCapability.getAffinityData(player)
                    .map(affinityData -> {
                        var config = ConfigManager.getPatriciaConfig();
                        int affinityLevel = affinityData.getAffinityData().getAffinityLevel();
                        return (float) config.calculateFireDamageMultiplier(affinityLevel);
                    })
                    .orElse(2.0f); // デフォルト200%
        }
    }

    // ========================================
    // 回復ボーナス管理システム（Phase 3で実装予定）
    // ========================================

    /**
     * 回復ボーナス管理の静的内部クラス
     */
    public static class RecoveryBonusManager {

        /**
         * 回復ボーナス発動（Phase 3で実装）
         */
        public static void triggerRecoveryBonus(Player player, String source) {
            // TODO: Phase 3で実装
            AnotherWorldsOrigin.LOGGER.debug("Recovery bonus triggered for {} from source: {}",
                    player.getDisplayName().getString(), source);
        }

        /**
         * 回復ボーナス終了処理（Phase 3で実装）
         */
        public static void endRecoveryBonus(Player player) {
            // TODO: Phase 3で実装
        }

        /**
         * 高親和度特典チェック（Phase 3で実装）
         */
        public static void checkHighAffinityBonus(Player player) {
            // TODO: Phase 3で実装
        }
    }

    // ========================================
    // 公開API
    // ========================================

    /**
     * プレイヤーがパトリシア種族になった時の初期化
     */
    public static void onPatriciaActivated(Player player) {
        if (!PlayerStateManager.isPatriciaOptimized(player)) {
            AnotherWorldsOrigin.LOGGER.warn(
                    "Attempted to activate Patricia heat vulnerability for non-Patricia player: {}",
                    player.getDisplayName().getString());
            return;
        }

        AnotherWorldsOrigin.LOGGER.info("Patricia {} Heat Vulnerability passive activated",
                player.getDisplayName().getString());

        // プレイヤーに通知
        player.sendSystemMessage(
                net.minecraft.network.chat.Component.literal("§c[Patricia] §f溶けた氷が固まるまでが発動しました"));

        // 現在の火炎ダメージ倍率を表示
        AffinityCapability.getAffinityData(player).ifPresent(affinityData -> {
            int level = affinityData.getAffinityData().getAffinityLevel();
            double multiplier = ConfigManager.getPatriciaConfig().calculateFireDamageMultiplier(level);
            player.sendSystemMessage(
                    net.minecraft.network.chat.Component.literal(
                            String.format("§c[熱ダメージ倍率] §c%.0f%% §7(親和度Lv.%d)", multiplier * 100, level)));
        });
    }

    /**
     * 親和度レベルアップ時の特別処理
     */
    public static void onAffinityLevelUp(Player player, int newLevel, int oldLevel) {
        if (!PlayerStateManager.isPatriciaOptimized(player)) {
            return;
        }

        var patriciaConfig = ConfigManager.getPatriciaConfig();

        // 熱ダメージ軽減の改善を表示
        double oldMultiplier = patriciaConfig.calculateFireDamageMultiplier(oldLevel);
        double newMultiplier = patriciaConfig.calculateFireDamageMultiplier(newLevel);
        double improvement = oldMultiplier - newMultiplier;

        if (improvement > 0.01) { // 有意な改善がある場合
            player.sendSystemMessage(
                    net.minecraft.network.chat.Component.literal(
                            String.format("§c[熱耐性向上] §7火炎ダメージ: %.0f%% → %.0f%% (§a-%.1f%%§7)",
                                    oldMultiplier * 100, newMultiplier * 100, improvement * 100)));
        }

        // 高親和度特典達成時の特別メッセージ
        if (newLevel == patriciaConfig.getHighAffinityThreshold()) {
            player.sendSystemMessage(
                    net.minecraft.network.chat.Component.literal(
                            "§l§c[Patricia] §r§f高親和度到達！熱への耐性が大幅に向上した"));
        }

        AnotherWorldsOrigin.LOGGER.info("Patricia {} heat vulnerability level up: {} -> {} (multiplier: {}x -> {}x)",
                player.getDisplayName().getString(), oldLevel, newLevel, oldMultiplier, newMultiplier);
    }

    // ========================================
    // イベントハンドラー
    // ========================================

    /**
     * 熱脆弱性イベントハンドラーの静的内部クラス
     */
    @Mod.EventBusSubscriber(modid = AnotherWorldsOrigin.MODID)
    public static class EventHandler {

        // デフォルト設定（パトリシア種族用）
        private static final Configuration DEFAULT_CONFIG = new Configuration(true, true, true, true);

        /**
         * 熱ダメージ脆弱性の処理
         */
        @SubscribeEvent(priority = EventPriority.HIGH)
        public static void onHeatDamage(LivingHurtEvent event) {
            if (!(event.getEntity() instanceof Player player)) {
                return;
            }

            if (!PlayerStateManager.isPatriciaOptimized(player)) {
                return;
            }

            net.minecraft.world.damagesource.DamageSource damageSource = event.getSource();

            if (HeatDamageCalculator.isHeatDamage(damageSource)) {
                float multiplier = HeatDamageCalculator.calculateFireDamageMultiplier(player);
                float originalDamage = event.getAmount();
                float newDamage = originalDamage * multiplier;

                event.setAmount(newDamage);

                // ログ出力
                AnotherWorldsOrigin.LOGGER.info("Patricia {} heat damage vulnerability: {} -> {} ({}x)",
                        player.getDisplayName().getString(),
                        String.format("%.2f", originalDamage),
                        String.format("%.2f", newDamage),
                        String.format("%.2f", multiplier));

                // デバッグ通知
                if (ConfigManager.getPatriciaConfig().shouldShowDebugMessages()) {
                    player.displayClientMessage(
                            net.minecraft.network.chat.Component.literal(String.format(
                                    "§c[熱ダメージ] §7%.1f → %.1f (%.0f%%)",
                                    originalDamage, newDamage, multiplier * 100)),
                            true);
                }

                // プレイヤーに分かりやすいフィードバック
                if (multiplier > 1.5f) { // 150%以上の場合のみ表示
                    player.displayClientMessage(
                            net.minecraft.network.chat.Component.literal(
                                    String.format("§c[溶けた氷が固まるまで] §7熱によるダメージ増加: +%.0f%%",
                                            (multiplier - 1.0f) * 100)),
                            true);
                }

                // 回復ボーナス発動トリガー（Phase 3で実装）
                RecoveryBonusManager.triggerRecoveryBonus(player, "heat_damage");
            }
        }

        // === EventHandler クラス内に追加するメソッド群 ===

        /**
         * Hot系バイオームでのダメージ増加
         */
        @SubscribeEvent(priority = EventPriority.LOW) // 火炎脆弱性の後に処理
        public static void onHotBiomeDamageIncrease(LivingHurtEvent event) {
            if (!(event.getEntity() instanceof Player player))
                return;
            if (!PlayerStateManager.isPatriciaOptimized(player))
                return;

            PlayerStateManager.BiomeState biomeState = PlayerStateManager.getBiomeState(player);
            if (biomeState != null && biomeState.isHotBiome()) {
                var config = ConfigManager.getPatriciaConfig();

                AffinityCapability.getAffinityData(player).ifPresent(affinityData -> {
                    int affinityLevel = affinityData.getAffinityData().getAffinityLevel();
                    double increase = config.calculateHotDamageIncrease(affinityLevel);

                    if (increase > 0) {
                        float originalDamage = event.getAmount();
                        float newDamage = originalDamage * (1.0f + (float) increase);
                        event.setAmount(newDamage);

                        // ログ出力
                        AnotherWorldsOrigin.LOGGER.info("Patricia {} hot biome damage increase: {} -> {} (+{}%)",
                                player.getDisplayName().getString(),
                                String.format("%.2f", originalDamage),
                                String.format("%.2f", newDamage),
                                String.format("%.1f", increase * 100));

                        // デバッグ通知
                        if (config.shouldShowDebugMessages()) {
                            player.displayClientMessage(
                                    net.minecraft.network.chat.Component.literal(String.format(
                                            "§6[Hot系] §7ダメージ増加: %.1f → %.1f (+%.1f%%)",
                                            originalDamage, newDamage, increase * 100)),
                                    true);
                        }
                    }
                });
            }
        }

        /**
         * Hot系バイオームでの満腹度処理（軽量版）
         */
        private static void handleHotBiomeExhaustion(Player player) {
            PlayerStateManager.BiomeState biomeState = PlayerStateManager.getBiomeState(player);
            if (biomeState == null || !biomeState.isHotBiome())
                return;

            // 行動中のみ追加疲労を適用
            if (PlayerStateManager.isExhaustionCausingAction(player)) {
                player.getFoodData().addExhaustion(0.1f); // 小刻みに追加で2倍効果

                var config = ConfigManager.getPatriciaConfig();
                if (config.shouldShowDebugMessages() && player.tickCount % 400 == 0) { // 20秒に1回
                    player.displayClientMessage(
                            net.minecraft.network.chat.Component.literal("§6[Hot系] §7満腹度消費増加中"),
                            true);
                }
            }
        }

        /**
         * ディメンション移動時の強制バイオーム更新
         */
        @SubscribeEvent
        public static void onPlayerChangedDimension(PlayerEvent.PlayerChangedDimensionEvent event) {
            Player player = event.getEntity();
            if (PlayerStateManager.isPatriciaOptimized(player)) {
                PlayerStateManager.updateBiomeState(player, true); // 強制更新
                AnotherWorldsOrigin.LOGGER.debug("Patricia {} biome state updated after dimension change",
                        player.getDisplayName().getString());
            }
        }

        /**
         * リスポーン時の強制バイオーム更新
         */
        @SubscribeEvent
        public static void onPlayerRespawn(PlayerEvent.PlayerRespawnEvent event) {
            Player player = event.getEntity();
            if (PlayerStateManager.isPatriciaOptimized(player)) {
                PlayerStateManager.updateBiomeState(player, true); // 強制更新
                AnotherWorldsOrigin.LOGGER.debug("Patricia {} biome state updated after respawn",
                        player.getDisplayName().getString());
            }
        }

        /**
         * プレイヤーログイン時の初期化
         */
        @SubscribeEvent
        public static void onPlayerLoggedIn(PlayerEvent.PlayerLoggedInEvent event) {
            Player player = event.getEntity();

            if (PlayerStateManager.isPatriciaOptimized(player)) {
                AnotherWorldsOrigin.LOGGER.info("Patricia {} heat vulnerability initialized on login",
                        player.getDisplayName().getString());
            }
        }

        /**
         * 軽量化されたティック処理（処理分散版）
         */
        @SubscribeEvent
        public static void onPlayerTick(net.minecraftforge.event.entity.living.LivingEvent.LivingTickEvent event) {
            if (!(event.getEntity() instanceof Player player))
                return;

            // 早期リターンでパトリシア以外を即座に除外
            if (!PlayerStateManager.isPatriciaOptimized(player))
                return;

            // 処理を分散（各ティックで1つの処理のみ実行）
            int tickMod = player.tickCount % 100;

            if (tickMod == 0) {
                // バイオーム変化確認（5秒ごと）
                PlayerStateManager.checkBiomeChangeIfMoved(player);

            } else if (tickMod == 25) {
                // 満腹度処理（5秒ごと、バイオーム確認と分散）
                handleHotBiomeExhaustion(player);

            } else if (tickMod == 50) {
                // キャッシュクリーンアップ（5秒ごと、他と分散）
                if (player.tickCount % 6000 == 50) { // 5分ごと
                    PlayerStateManager.cleanupCache();
                    PlayerStateManager.monitorCacheSize();
                }
            }
        }
    }
}